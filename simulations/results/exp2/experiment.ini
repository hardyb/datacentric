

[Config DC_QueryBased_TestPathCostMethod]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  


# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 100

#repeat = 25
repeat = 10
seed-set = ${repetition}
num-rngs = 2

#**.estimationMethod = "experiment"
#**.estimationMethod = "maximum"

#**.pathCostMethod = 2 # PC_ADD_LQI 0, PC_MULT_LQI 1, PC_LOWEST_MAX_LINK 2, PC_ZIGBEE 3, PC_ZIGBEE_LOWEST_MAX_LINK 4
**.pathCostMethod = 4 #${pcm=0,  2} 

#**.net.routingDelay = 2 * intuniform(2, 64)






# NBNBNB
# We have temporarily hadthe DC network layer take the sinkFor
# string as is rather than concatonating short or long context
# Need to think more about this   

# In this run sink uses AsIs data not shortest or longest context

#**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0
#**.region[1].regionHost[0].nodeStartTime = 0
#**.region[1].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0" 
#**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived

#**.region[2].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[2].regionHost[1].actionThreads = "demand_one_pkt.txt"
#**.region[2].regionHost[1].scheduleStartTime = 0
#**.region[2].regionHost[1].isAppliance = true

**.phy.transmitterPower				 = 1.0mW  	#[mW]
#**.phy.transmitterPower				 = 0.2mW  	#[mW]

#**.rxSetupTime = 0.00108s
#**.phy.sensitivity					 = -85dBm	#[dBm]
**.phy.sensitivity					 = -92dBm	#[dBm]
#**.aTurnaroundTime = 0.000192 s

**.TransmissionAntennaGainIndB = -1.5dB 
**.ReceiveAntennaGainIndB = -1.5dB



#**.phy.pathLossAlpha				 = 4 # Adapt

**.NoiseGenerator = "MyNoiseGenerator"
**.noiseDistribution = "rayleigh"
**.noiseStart = 1.9


#**.experimentSet = ${expSet=-96,  -90}
**.noiseLower = -97.0
#**.noiseLower = ${expSet} - 4
#**.noiseUpper = ${expSet} + 4
#**.noiseUpper = ${nu=-92..-67} #-87.0
#**.noiseUpper = ${nu=-92, -86, -80, -74, -68} #-87.0
#**.noiseUpper = ${nu=-97, -95, -93, -91, -89, -87, -85} #-87.0
**.noiseUpper = ${nu=-92, -86}




# NB: NEED TO DO SOMETHING ABOUT DELAY
# CURRENTLY FOR XBEE PRINT
# TRY ANY WAY COS MAY NOT AFFECT PATH COST TEST


**.host[0].app.sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0"
**.host[0].app.simAppTerminationReason = 2 # when all have arrived
#**.host[0].app.nodeStartTime = 2
#**.host[0].app.setParametersDirectly = true
# Starts at zero by default


# called in the context of module

#**.experimentSet = ${expSet=1,  2,  3,  4}

**.host[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[1].app.actionThreads = "demand_multi_pkt_1.txt"
#**.host[1].app.scheduleStartTime = ${node1=0,  0,  0,  0 ! expSet}
#**.host[1].app.scheduleStartTime = ${node1=2,  2,  2,  2 ! expSet}
**.host[1].app.scheduleStartTime = 2
# Startup at zero by default
**.host[1].app.isAppliance = true

**.host[2].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[2].app.actionThreads = "demand_multi_pkt_2.txt"
#**.host[2].app.scheduleStartTime = ${node2=10,  0,  0,  0 ! expSet}
#**.host[2].app.scheduleStartTime = ${node2=10,  2,  2,  2 ! expSet}
**.host[2].app.scheduleStartTime = 2
# Startup at zero by default
**.host[2].app.isAppliance = true

**.host[3].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[3].app.actionThreads = "demand_multi_pkt_3.txt"
#**.host[3].app.scheduleStartTime = ${node3=10,  10,  0,  0 ! expSet}
#**.host[3].app.scheduleStartTime = ${node3=10,  10,  2,  2 ! expSet}
**.host[3].app.scheduleStartTime = 2
# Startup at zero by default
**.host[3].app.isAppliance = true

**.host[4].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[4].app.actionThreads = "demand_multi_pkt_4.txt"
#**.host[4].app.scheduleStartTime = ${node4=10,  10,  10,  0 ! expSet}
#**.host[4].app.scheduleStartTime = ${node4=10,  10,  10,  2 ! expSet}
**.host[4].app.scheduleStartTime = 2
# Startup at zero by default
**.host[4].app.isAppliance = true








# Simulation completion
sim-time-limit = 15s
#**.expectedDataArrivals = ${expected=1,  2,  3,  4 ! expSet}
**.expectedDataArrivals = 48


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";












[Config DC_RSSI_Test]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  


# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 2

#repeat = 25
#repeat = 10
#seed-set = ${repetition}
#num-rngs = 2

#**.estimationMethod = "experiment"
#**.estimationMethod = "maximum"


#**.phy.transmitterPower				 = 0.1mW  	#[mW]
**.phy.transmitterPower				 = 1.0mW  	#[mW]

#**.rxSetupTime = 0.00108s
#**.phy.sensitivity					 = -85dBm	#[dBm]
**.phy.sensitivity					 = -92dBm	#[dBm]
#**.aTurnaroundTime = 0.000192 s


# 1.0mw alpha 5, sens -85, gain zero
# 52, 72, 87, fail, fail

# 1.0mw alpha 5, sens -100, gain zero
# 52, 72, 87, fail, fail

# 1.0mw alpha 5, sens -109, gain zero
# 52, 63, 78, 87, fail

**.TransmissionAntennaGainIndB = -1.5dB 
**.ReceiveAntennaGainIndB = -1.5dB
#**.TransmissionAntennaGainIndB = -3dB 
#**.ReceiveAntennaGainIndB = -3dB

**.phy.pathLossAlpha				 = 4 # Adapt


**.NoiseGenerator = "MyNoiseGenerator"



**.host[0].app.sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0" # Take AS IS
**.host[0].app.simAppTerminationReason = 2 # when all have arrived
# Starts at zero by default
**.host[0].mobility.initialX = 0m
**.host[0].mobility.initialY = 0m
**.host[0].mobility.initialZ = 0m






**.host[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[1].app.actionThreads = "demand_multi_pkt.txt"
**.host[1].app.scheduleStartTime = 1
# Startup at zero by default
**.host[1].app.isAppliance = true
#**.host[1].mobility.initialX = 9.9m
#**.host[1].mobility.initialY = 11.9m
#**.host[1].mobility.initialZ = 0m
**.host[1].mobility.initialX = ${xVal=0.05m,  2.5m,  5m,  7.5m, 9.99m}
**.host[1].mobility.initialY = ${yVal=0.05m,  3m,  6m,  9m, 11.99m ! xVal}
**.host[1].mobility.initialZ = 0m



#0.7071067811













# Simulation completion
sim-time-limit = 15s
**.expectedDataArrivals = 12












[Config DC_QueryBased_OnHardware]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  


# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 15

#repeat = 25
repeat = 10
seed-set = ${repetition}
num-rngs = 3 # For this run, have used rng=2 for random placement in StationaryMobility.ned

#**.estimationMethod = "experiment"
#**.estimationMethod = "maximum"




# NBNBNB
# We have temporarily hadthe DC network layer take the sinkFor
# string as is rather than concatonating short or long context
# Need to think more about this   

# In this run sink uses AsIs data not shortest or longest context

#**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0
#**.region[1].regionHost[0].nodeStartTime = 0
#**.region[1].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0" 
#**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived

#**.region[2].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[2].regionHost[1].actionThreads = "demand_one_pkt.txt"
#**.region[2].regionHost[1].scheduleStartTime = 0
#**.region[2].regionHost[1].isAppliance = true

**.phy.transmitterPower				 = 1.0mW  	#[mW]
#**.phy.transmitterPower				 = 0.2mW  	#[mW]

#**.rxSetupTime = 0.00108s
#**.phy.sensitivity					 = -85dBm	#[dBm]
**.phy.sensitivity					 = -92dBm	#[dBm]
#**.aTurnaroundTime = 0.000192 s

**.TransmissionAntennaGainIndB = -1.5dB 
**.ReceiveAntennaGainIndB = -1.5dB

# XBee value for this is 200ms !!
#**.macAckWaitDuration = 0.02s # this is in the common file

# Also After the 200ms XBee waits random period upto 48ms before resend
# So...
**.macAckWaitDuration = uniform(0.200s, 0.248s) 
# Is (while not identical) a reasonable aproximation to this


# With default = 5 this is same as if XBee RR=2
#**.macMaxFrameRetries = 5 # Data centric WAS 10 

**.phy.pathLossAlpha				 = 4 # 4 Deduced from Hardware RSSI / Pkt Loss experiment

**.NoiseGenerator = "MyNoiseGenerator"
**.noiseDistribution = "rayleigh"
#**.noiseStart = 1.9
**.noiseLower = -97.0
**.noiseUpper = -87.0



**.host[0].app.sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0"
**.host[0].app.simAppTerminationReason = 2 # when all have arrived
**.host[0].app.nodeStartTime = 2
#**.host[0].app.setParametersDirectly = true
# Starts at zero by default
#**.host[0].app.nodeStartTime = 0

# Go back to without this for now
#**.host[*].app.nodeStartTime = uniform(0, 0.15)


# called in the context of module

**.experimentSet = ${expSet=1,  2,  3,  4}

**.host[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[1].app.actionThreads = "demand_one_pkt.txt"
#**.host[1].app.scheduleStartTime = ${node1=0,  0,  0,  0 ! expSet}
**.host[1].app.scheduleStartTime = ${node1=2,  2,  2,  2 ! expSet}
# Startup at zero by default
**.host[1].app.isAppliance = true

**.host[2].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[2].app.actionThreads = "demand_one_pkt.txt"
#**.host[2].app.scheduleStartTime = ${node2=10,  0,  0,  0 ! expSet}
**.host[2].app.scheduleStartTime = ${node2=10,  2,  2,  2 ! expSet}
# Startup at zero by default
**.host[2].app.isAppliance = true

**.host[3].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[3].app.actionThreads = "demand_one_pkt.txt"
#**.host[3].app.scheduleStartTime = ${node3=10,  10,  0,  0 ! expSet}
**.host[3].app.scheduleStartTime = ${node3=10,  10,  2,  2 ! expSet}
# Startup at zero by default
**.host[3].app.isAppliance = true

**.host[4].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[4].app.actionThreads = "demand_one_pkt.txt"
#**.host[4].app.scheduleStartTime = ${node4=10,  10,  10,  0 ! expSet}
**.host[4].app.scheduleStartTime = ${node4=10,  10,  10,  2 ! expSet}
# Startup at zero by default
**.host[4].app.isAppliance = true








# Simulation completion
sim-time-limit = 3s
**.expectedDataArrivals = ${expected=1,  2,  3,  4 ! expSet}


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";











[Config DC_QueryBased_VERY_TEMP_TEST]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  


# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 250

repeat = 25
seed-set = ${repetition}
num-rngs = 2

**.estimationMethod = "experiment"


# NBNBNB
# We have temporarily hadthe DC network layer take the sinkFor
# string as is rather than concatonating short or long context
# Need to think more about this   

# In this run sink uses AsIs data not shortest or longest context

**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0
**.region[1].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x0" 
**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived

**.region[2].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
**.region[2].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[2].regionHost[1].scheduleStartTime = 0
**.region[2].regionHost[1].isAppliance = true



# Simulation completion
sim-time-limit = 7s
**.expectedDataArrivals = 1


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";










[Config DC_QueryBased_With_Interference]

# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 250

repeat = 25
seed-set = ${repetition}
num-rngs = 2


**.NoiseGenerator = "MyNoiseGenerator"


**.host[0].app.sinkFor = "\x2"+"\x2"+"\x0"
**.host[0].app.simAppTerminationReason = 2 # when all have arrived
**.host[0].mobility.initialX = 0.1m
**.host[0].mobility.initialY = 0.1m
**.host[0].mobility.initialZ = 0.75m
**.host[0].app.setParametersDirectly = true


**.host[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[1].app.actionThreads = "demand_one_pkt.txt"
#**.host[1].app.scheduleStartTime = ${increment=0..1 step 0.1}
**.host[1].app.scheduleStartTime = ${increment=5}
**.host[1].app.isAppliance = true

**.host[2].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[2].app.actionThreads = "demand_one_pkt.txt"
**.host[2].app.scheduleStartTime = ${increment}
**.host[2].app.isAppliance = true

**.host[3].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[3].app.actionThreads = "demand_one_pkt.txt"
**.host[3].app.scheduleStartTime = ${increment}
**.host[3].app.isAppliance = true

**.host[4].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[4].app.actionThreads = "demand_one_pkt.txt"
**.host[4].app.scheduleStartTime = ${increment}
**.host[4].app.isAppliance = true



# Simulation completion
#sim-time-limit = 7s
sim-time-limit = 12s
**.expectedDataArrivals = 4


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";























[Config DC_CollabBasedRegions]



description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
#**.numHosts = 250
**.numHosts = ${numNodes=50..250 step 10}
**.numMainsNodes = 25

repeat = 25
seed-set = ${repetition}
num-rngs = 2

#**.estimationMethod = "experiment"


# think about start times
# think about schedule start times

#**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
#**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0


#**.region[1].regionHost[0].nodeStartTime = 0
#**.region[1].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x2"+"\xFF"+"\x6"+"\x1"+"\x0"

# Nodes starting one after another, measure just expected arrivals
#**.app.delayData = 4

**.region[1].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[0].actionThreads = "collab_one_pkt_1.txt"
**.region[1].regionHost[0].nodeStartTime = 0
**.region[1].regionHost[0].scheduleStartTime = 0

**.region[1].regionHost[1].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[1].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[1].actionThreads = "collab_one_pkt_2.txt"
**.region[1].regionHost[1].nodeStartTime = 1
**.region[1].regionHost[1].scheduleStartTime = 1

**.region[1].regionHost[2].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[2].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[2].actionThreads = "collab_one_pkt_3.txt"
**.region[1].regionHost[2].nodeStartTime = 2
**.region[1].regionHost[2].scheduleStartTime = 2

**.region[1].regionHost[3].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[3].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[3].actionThreads = "collab_one_pkt_4.txt"
**.region[1].regionHost[3].nodeStartTime = 3
**.region[1].regionHost[3].scheduleStartTime = 3

**.region[1].regionHost[4].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[4].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[4].actionThreads = "collab_one_pkt_5.txt"
**.region[1].regionHost[4].nodeStartTime = 4
**.region[1].regionHost[4].scheduleStartTime = 4





# Simulation completion
sim-time-limit = 30s
**.expectedDataArrivals = 10 # 0, 1, 2, 3 & 4 respectively



# Scratch Pad
#**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived
#**.region[1].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[1].regionHost[1].actionThreads = "c_one_pkt.txt"
#**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
#**.region[1].regionHost[1].isAppliance = true





# NB NB: BE VER CAREFUL TO CHECK ALL PARAMETERS - HERE ARE SOME POINTERS
#############################################################################
# CHECK -  actionThreads - this contains the data name which may be region specific
# Or have some other adaptation for the specific experiemnt scenarioi
# CHECK - simAppTerminationReason, some scenarios have variable number of arrivals
# amd we we would show absolute arrival results, not %.
 
[Config DC_CollabBasedRegions_temp]


# DC_CollabBasedRegions_5c
# Same as *_4c only in a single region, region 4


# DC_CollabBasedRegions_4c
# Just like DC_CollabBasedRegions_4b only the data is sent 0.5s after start up


# DC_CollabBasedRegions_4b
# 250 network size.  Nodes start up at intervals, the test
# is repeated with an interval of zero up to an interval of 5 
# in steps of 0.25s.
# Data is sent 0.25 after start up.


# DC_CollabBasedRegions_3

# This experiment uses a single region (reguires propertyAndRegions2.ini to be used)
# 5 node start ups fixed at 1s apart
# vary the network size 50..250 in steps of 10  
# During thsi run the code was set to use collab' data namse AS IS. 



description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 250
#**.numHosts = ${numNodes=50..250 step 10} # 21 steps
**.numMainsNodes = 25 # ?????????????????????

repeat = 25 # 25 * 21 = 525 Should be OK with GUI
seed-set = ${repetition}
num-rngs = 2

# For the moment just count failures, don't estimate them
#**.estimationMethod = "experiment"


# think about start times
# think about schedule start times

#**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
#**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0


#**.region[1].regionHost[0].nodeStartTime = 0
#**.region[1].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x2"+"\xFF"+"\x6"+"\x1"+"\x0"

# Nodes starting one after another, measure just expected arrivals
# If the nodes will startup one after the at 1s intervals then
# perhaps leave this OFF since the packets would be recorded as arriving very late! 
#**.app.delayData = 4 




# in the case of collaboration where data is sent immediately or at least
# straight after reinforcement when node converges, one cannot guarentee
# to reach all the other collaborators since other reinforcements are still ongoing
# using the 25th random deployment
# Out of a possible 20, at 0 or 0.1 we get 11.  At 0.2 13, at 0.25 15 
# Bizarely at 0.3 12, at 0.5 20


#**.region[0].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[0].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x0"
#**.region[0].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[0].regionHost[0].actionThreads = "collab_multi_pkt.txt"
**.region[0].regionHost[0].nodeStartTime = (${interval = 0..2 step 0.1} * 0)
**.region[0].regionHost[0].scheduleStartTime = (${interval} * 0) + 0.5

#**.region[0].regionHost[1].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[0].regionHost[1].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x0"
#**.region[0].regionHost[1].simAppTerminationReason = 2 # when all have arrived
**.region[0].regionHost[1].actionThreads = "collab_multi_pkt.txt"
**.region[0].regionHost[1].nodeStartTime = (${interval} * 1)
**.region[0].regionHost[1].scheduleStartTime = (${interval} * 1) + 0.5

#**.region[0].regionHost[2].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[0].regionHost[2].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x0"
#**.region[0].regionHost[2].simAppTerminationReason = 2 # when all have arrived
**.region[0].regionHost[2].actionThreads = "collab_multi_pkt.txt"
**.region[0].regionHost[2].nodeStartTime = (${interval} * 2)
**.region[0].regionHost[2].scheduleStartTime = (${interval} * 2) + 0.5

#**.region[0].regionHost[3].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[0].regionHost[3].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x0"
#**.region[0].regionHost[3].simAppTerminationReason = 2 # when all have arrived
**.region[0].regionHost[3].actionThreads = "collab_multi_pkt.txt"
**.region[0].regionHost[3].nodeStartTime = (${interval} * 3)
**.region[0].regionHost[3].scheduleStartTime = (${interval} * 3) + 0.5

#**.region[0].regionHost[4].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[0].regionHost[4].collaboratorFor = "\x42"+"\x3"+"\xFF"+"\x6"+"\x0"
#**.region[0].regionHost[4].simAppTerminationReason = 2 # when all have arrived
**.region[0].regionHost[4].actionThreads = "collab_multi_pkt.txt"
**.region[0].regionHost[4].nodeStartTime = (${interval} * 4)
**.region[0].regionHost[4].scheduleStartTime = (${interval} * 4) + 0.5








# Simulation completion
sim-time-limit = 250s
#**.expectedDataArrivals = 20 # each of 5 receive from other 4
**.expectedDataArrivals = 200 # each node starting up will deliver 0, 1, 2, 3 & 4 respectively



# Scratch Pad
#**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived
#**.region[1].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[1].regionHost[1].actionThreads = "c_one_pkt.txt"
#**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
#**.region[1].regionHost[1].isAppliance = true










[Config DC_QueryBasedRegions]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  


# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 250

repeat = 25
seed-set = ${repetition}
num-rngs = 2

**.estimationMethod = "experiment"


# NBNBNB
# We have temporarily hadthe DC network layer take the sinkFor
# string as is rather than concatonating short or long context
# Need to think more about this   



**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0
**.region[1].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x1"+"\x0"
**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
**.region[1].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
**.region[1].regionHost[1].isAppliance = true

**.region[2].regionHost[0].nodeStartTime = ${increment} * 1
**.region[2].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x2"+"\x0"
**.region[2].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[2].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
**.region[2].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[2].regionHost[1].scheduleStartTime = (${increment} * 1)+0.5
**.region[2].regionHost[1].isAppliance = true

**.region[3].regionHost[0].nodeStartTime = ${increment} * 2
**.region[3].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x3"+"\x0"
**.region[3].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[3].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
**.region[3].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[3].regionHost[1].scheduleStartTime = (${increment} * 2)+0.5
**.region[3].regionHost[1].isAppliance = true

**.region[4].regionHost[0].nodeStartTime = ${increment} * 3
**.region[4].regionHost[0].sinkFor = "\x2"+"\x2"+"\xFF"+"\x6"+"\x4"+"\x0"
**.region[4].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[4].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0"
**.region[4].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[4].regionHost[1].scheduleStartTime = (${increment} * 3)+0.5
**.region[4].regionHost[1].isAppliance = true



# Simulation completion
sim-time-limit = 7s
**.expectedDataArrivals = 4


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";




[Config DC_QueryBased]

# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
**.numHosts = 250

repeat = 25


# Control Unit related parameters
#**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours, ie never
#**.manetrouting.suppress_rreps_on_proactive_rreqs = true
#**.fixhost[0].udpApp.confirmRegistration = false
#**.fixhost[0].app.nodeStartTime = 0.01


#nodeStartTime
#scheduleStartTime
#timeSinkRegisterWithControlUnit

# heat_sensor_one_pkt.txt

**.host[0].app.sinkFor = "\x2"+"\x2"+"\x0"
**.host[0].app.simAppTerminationReason = 2 # when all have arrived
**.host[0].mobility.initialX = 0.1m
**.host[0].mobility.initialY = 0.1m
**.host[0].mobility.initialZ = 0.75m
**.host[0].app.setParametersDirectly = true


**.host[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[1].app.actionThreads = "demand_one_pkt.txt"
**.host[1].app.scheduleStartTime = ${increment=0..1 step 0.1}
**.host[1].app.isAppliance = true

**.host[2].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[2].app.actionThreads = "demand_one_pkt.txt"
**.host[2].app.scheduleStartTime = ${increment}
**.host[2].app.isAppliance = true

**.host[3].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[3].app.actionThreads = "demand_one_pkt.txt"
**.host[3].app.scheduleStartTime = ${increment}
**.host[3].app.isAppliance = true

**.host[4].app.sourceFor = "\x2"+"\x2"+"\x0"
**.host[4].app.actionThreads = "demand_one_pkt.txt"
**.host[4].app.scheduleStartTime = ${increment}
**.host[4].app.isAppliance = true



# Simulation completion
sim-time-limit = 7s
**.expectedDataArrivals = 4


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";









[Config DataCentric_Experiment_1]



# experiment

# half the recommended number from building automation RFC
# used for routing
#**.numHosts = 125
**.numHosts = ${numNodes=50..125 step 1}

#sim-time-limit = 50500s

description = "DataCentric_Experiment_1"

# try this
#        for i=0..10 {
#            **.region[1..4].regionHost[i].nodeStartTime = i
#        }

################## Delete afterwards

# Sources 
**.region[1..4].regionHost[0].sourceFor = "\x83"+"\x2"+"\x0"
**.region[1..4].regionHost[0].actionThreads = "heat_sensor.txt"

# Sinks
**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"

**.region[1].regionHost[1..3].isAppliance = true
**.region[2].regionHost[1..3].isAppliance = true
**.region[3].regionHost[1..3].isAppliance = true
**.region[4].regionHost[1..3].isAppliance = true

# Simulation completion
sim-time-limit = 8000s
**.expectedDataArrivals = 156


# Timed behaviour

# sink start times
**.region[1].regionHost[1].nodeStartTime = 43.0 # enable send/receive send grads and hello
**.region[1].regionHost[2].nodeStartTime = 44.0 # enable send/receive send grads and hello
**.region[1].regionHost[3].nodeStartTime = 45.0 # enable send/receive send grads and hello

**.region[2].regionHost[1].nodeStartTime = 46.0 # enable send/receive send grads and hello
**.region[2].regionHost[2].nodeStartTime = 47.0 # enable send/receive send grads and hello
**.region[2].regionHost[3].nodeStartTime = 48.0 # enable send/receive send grads and hello

**.region[3].regionHost[1].nodeStartTime = 49.0 # enable send/receive send grads and hello
**.region[3].regionHost[2].nodeStartTime = 50.0 # enable send/receive send grads and hello
**.region[3].regionHost[3].nodeStartTime = 51.0 # enable send/receive send grads and hello

**.region[4].regionHost[1].nodeStartTime = 52.0 # enable send/receive send grads and hello
**.region[4].regionHost[2].nodeStartTime = 53.0 # enable send/receive send grads and hello
**.region[4].regionHost[3].nodeStartTime = 54.0 # enable send/receive send grads and hello


# source start times
**.region[1].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[2].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[3].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[4].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello

**.region[1..4].regionHost[*].nodeStartTime = 0 # enable send/receive send grads and hello




# Not used in data centric?
#**.region[1].regionHost[1].timeSinkRegisterWithControlUnit = 43.5
#**.region[1].regionHost[2].timeSinkRegisterWithControlUnit = 44.5
#**.region[1].regionHost[3].timeSinkRegisterWithControlUnit = 45.5
#**.region[2].regionHost[1].timeSinkRegisterWithControlUnit = 46.5
#**.region[2].regionHost[2].timeSinkRegisterWithControlUnit = 47.5
#**.region[2].regionHost[3].timeSinkRegisterWithControlUnit = 48.5
#**.region[3].regionHost[1].timeSinkRegisterWithControlUnit = 49.5
#**.region[3].regionHost[2].timeSinkRegisterWithControlUnit = 50.5
#**.region[3].regionHost[3].timeSinkRegisterWithControlUnit = 51.5
#**.region[4].regionHost[1].timeSinkRegisterWithControlUnit = 52.5
#**.region[4].regionHost[2].timeSinkRegisterWithControlUnit = 53.5
#**.region[4].regionHost[3].timeSinkRegisterWithControlUnit = 54.5



# Foursource nondes begin sending data at 70, 71, 72 and 73 seconds
**.region[1].regionHost[0].scheduleStartTime = 70.00
**.region[2].regionHost[0].scheduleStartTime = 71.00
**.region[3].regionHost[0].scheduleStartTime = 72.00
**.region[4].regionHost[0].scheduleStartTime = 73.00
**.region[1..4].regionHost[*].scheduleStartTime = 3.00



