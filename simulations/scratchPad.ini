





[Config DataCentricScenario_1]

#125 heterogeneous nodes particiapte in routing inside the property









[Config DataCentricScenario_2]
extends = DataCentricScenario_1

# 3 appliances in each room/region.  The sensor in each region sends data
# to the interested appliances 


# One Source in each reagion
# three sinks in each region 
**.region[1..4].regionHost[0].sourceFor = "\x83"+"\x1"+"\x0"
**.region[1].regionHost[0].actionThreads = "OccupancyLivingRoom.txt"
**.region[2].regionHost[0].actionThreads = "OccupancyKitchen.txt"
**.region[3].regionHost[0].actionThreads = "OccupancyBedRoom.txt"
**.region[4].regionHost[0].actionThreads = "OccupancyDiningRoom.txt"
#**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
#**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
#**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
#**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"


**.region[1..4].regionHost[1..3].isAppliance = true

#**.region[1].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[2].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[3].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[4].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"



**.region[1].regionHost[1].actionThreads = "TV.txt"
**.region[1].regionHost[2].actionThreads = "PVR.txt"
**.region[1].regionHost[3].actionThreads = "LivingRoomLights.txt"

**.region[2].regionHost[1].actionThreads = "PS3.txt"
**.region[2].regionHost[2].actionThreads = "CRT.txt"
**.region[2].regionHost[3].actionThreads = "Laptop.txt"

**.region[3].regionHost[1].actionThreads = ""
**.region[3].regionHost[2].actionThreads = ""
**.region[3].regionHost[3].actionThreads = ""

**.region[4].regionHost[1].actionThreads = ""
**.region[4].regionHost[2].actionThreads = ""
**.region[4].regionHost[3].actionThreads = ""




#**.region[2].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[3].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"
#**.region[4].regionHost[1..3].sourceFor = "\x2"+"\x2"+"\x0"






# One sink/source node initiate binding every second

# TEMP
# No special control unit
#**.host[64].app.nodeStartTime = 1.0


#**.region[1].regionHost[0].nodeStartTime = 1.0 # enable send/receive send grads and hello
#**.region[1].regionHost[1].nodeStartTime = 2.0 # enable send/receive send grads and hello
#**.region[1].regionHost[2].nodeStartTime = 3.0 # enable send/receive send grads and hello
#**.region[1].regionHost[3].nodeStartTime = 4.0 # enable send/receive send grads and hello
#**.region[2].regionHost[0].nodeStartTime = 5.0 # enable send/receive send grads and hello
#**.region[2].regionHost[1].nodeStartTime = 6.0 # enable send/receive send grads and hello
#**.region[2].regionHost[2].nodeStartTime = 7.0 # enable send/receive send grads and hello
#**.region[2].regionHost[3].nodeStartTime = 8.0 # enable send/receive send grads and hello
#**.region[3].regionHost[0].nodeStartTime = 9.0 # enable send/receive send grads and hello
#**.region[3].regionHost[1].nodeStartTime = 10.0 # enable send/receive send grads and hello
#**.region[3].regionHost[2].nodeStartTime = 11.0 # enable send/receive send grads and hello
#**.region[3].regionHost[3].nodeStartTime = 12.0 # enable send/receive send grads and hello
#**.region[4].regionHost[0].nodeStartTime = 13.0 # enable send/receive send grads and hello
#**.region[4].regionHost[1].nodeStartTime = 14.0 # enable send/receive send grads and hello
#**.region[4].regionHost[2].nodeStartTime = 15.0 # enable send/receive send grads and hello
#**.region[4].regionHost[3].nodeStartTime = 16.0 # enable send/receive send grads and hello
#**.region[*].regionHost[*].nodeStartTime = 17.0 # enable send/receive send grads and hello



**.region[*].regionHost[*].nodeStartTime = 1.0 # enable send/receive send grads and hello

# Reg with control unit only applies to AODV (may create a 'similar' paramteter for data centric)
# At present data centric interests and adverts are issued at start up time
**.region[*].regionHost[*].timeSinkRegisterWithControlUnit = 1.0
**.region[*].regionHost[*].timeSourceRegisterWithControlUnit = 1.0
**.region[*].regionHost[*].scheduleStartTime = 3.0 # begin pattern of sending data, eg temp, watts, occupancy


#**.host[*].app.nodeStartTime = 1.0 # enable send/receive send grads and hello
#**.host[*].app.scheduleStartTime = 3.00 # begin pattern of sending data, eg temp, watts, occupancy


# Foursource nondes begin sending data at 20, 21 and 23 seconds
#**.region[1].regionHost[0].scheduleStartTime = 20.00
#**.region[2].regionHost[0].scheduleStartTime = 21.00
#**.region[3].regionHost[0].scheduleStartTime = 22.00
#**.region[4].regionHost[0].scheduleStartTime = 23.00
#**.region[*].regionHost[*].scheduleStartTime = 3.00





[Config DataCentricScenario_3]
# Same scenario but with appliances interested in occupancy events

extends = DataCentricScenario_2

**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"
**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x1"+"\x0"





[Config DataCentricScenario_4]
extends = DataCentricScenario_1

# In this scenario several appliance connect to collaborate by biding for 
# time to operate.  Each appliance is a collborative sink for bids and
# each appliance sends bids when they want to operate
# each appliance operates shortest job next scheduling in response to the 
# distributed bid messages 


#**.region[0].regionHost[1..5].isAppliance = true
**.region[0].regionHost[1..4].isAppliance = true


**.region[0].regionHost[0].collaboratorInitiatorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID
**.region[0].regionHost[1].collaboratorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID
**.region[0].regionHost[2].collaboratorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID
**.region[0].regionHost[3].collaboratorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID
**.region[0].regionHost[4].collaboratorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID
#**.region[0].regionHost[5].collaboratorFor = "\x42"+"\x1"+"\x0" # DEMAND_COLLABERATIONBASED, BID



#**.region[0].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # DEMAND_COLLABERATIONBASED, BID
#**.region[0].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # DEMAND_COLLABERATIONBASED, BID
#**.region[0].regionHost[2].sourceFor = "\x2"+"\x2"+"\x0" # DEMAND_COLLABERATIONBASED, BID
#**.region[0].regionHost[3].sourceFor = "\x2"+"\x2"+"\x0" # DEMAND_COLLABERATIONBASED, BID
#**.region[0].regionHost[4].sourceFor = "\x2"+"\x2"+"\x0" # DEMAND_COLLABERATIONBASED, BID



**.region[0].regionHost[*].nodeStartTime = 1.0 # enable send/receive send grads and hello
**.region[0].regionHost[*].scheduleStartTime = 3.0 # begin pattern of sending data, eg temp, watts, occupancy





**.region[0].regionHost[1].actionThreads = "BidDishWasher.txt"
**.region[0].regionHost[2].actionThreads = "BidKettle.txt"
**.region[0].regionHost[3].actionThreads = "BidMicrowave.txt"
**.region[0].regionHost[4].actionThreads = "BidTumbleDryer.txt"
#**.region[0].regionHost[5].actionThreads = "OccupancyLivingRoom.txt"









































########################################################################################
# ALL COMMENT BELOW HERE
########################################################################################



##############################################################################
#       Parameters for the application-layer                                 #
##############################################################################

#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";




#**.fixhost[*].udpAppType = "UDPBurstAndBroadcast"
#**.udpApp.localPort = 1234
#**.udpApp.destPort = 1234
#**.routingFile = ""
#**.ip.procDelay = 10us
#**.arp.retryTimeout = 1s
#**.arp.retryCount = 3
#**.arp.cacheTimeout = 100s
#**.routingProtocol="AODVUU"
# Not really used
#**.udpApp.messageLength = 64B # Bytes
#**.udpApp.sendInterval = 3s #0.25s + uniform(-0.001s,0.001s,1)
#**.udpApp.burstDuration = 10s #uniform(1s,4s,1) #uniform(1s,4s,1)
#**.udpApp.sleepDuration = 0s
#**.udpApp.chooseDestAddrMode = "perBurst"
#**.udpApp.stopTime = 0s # uniform(10s,20s,1))
#**.udpApp.startTime = 30s #uniform(20s,35s)
#**.udpApp.delayLimit =200s
#**.udpApp.destAddrRNG = 1


##############################################################################
#       Parameters for the network interface and IFqueue               #
##############################################################################
#**.nic.ifqType						 = "DropTailQueue"
#**.ifq.frameCapacity				 = 20
#**.ifq.dropPk.


# AODV Parameters
#**.log_to_file = false
#**.hello_jittering = true
#**.optimized_hellos = true
#**.expanding_ring_search = false
#**.local_repair = true
#**.rreq_gratuitous = true
#**.rt_log_interval = 0
#**.unidir_hack = 0
#**.internet_gw_mode = 0
#**.receive_n_hellos = 1
#**.ratelimit = 1000
#**.llfeedback = false # //1000
#**.wait_on_reboot = 0
#**.active_timeout = 1800000 # // time in ms (30 mins)
#**.internet_gw_address = "0.0.0.0"
#**.useHover = false
#**.broadcastDelay=uniform(0s,0.01s) # 10 mseconds
#**.unicastDelay=uniform(0s,0.005s)


#**.host[64].udpApp.isControlUnit = true
#**.host[*].udpApp.controlUnit = "csma802154net.fixhost[64]"

# Enable the possibility of broadcast communication
#**.host[*].udpApp.setBroadcast = true
#**.host[*].udpApp.outputInterfaceMulticastBroadcast = "wlan"
