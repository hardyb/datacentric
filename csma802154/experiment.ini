


[Config AODV_CollaborationBased]

# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
#*.numFixHosts = 250
*.numFixHosts = 50

repeat = 25
seed-set = ${repetition}
num-rngs = 2


# I think we may not want estimation because I think we have to
# set the simulation finishing time far enough ahead to have
# enough breaks between sequential sendings 
#**.estimationMethod = "experiment"


# In order that we can measure the cost in time of successfully sending all first 
#data transmissions including overhead
#**.app.delayData = 3 # Send data at earliest oportunity




# Control Unit related parameters
**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours, ie never
**.manetrouting.suppress_rreps_on_proactive_rreqs = true

# Multiple simultaneous RREPs can affect registration with CU
# Retries required and so confirmation required 
**.fixhost[*].udpApp.BindingNumTries = 3
**.fixhost[*].udpApp.BindingTimeOut = 0.75
**.fixhost[0].udpApp.confirmRegistration = true


#**.fixhost[0].app.nodeStartTime = 0.01 # default zero




#nodeStartTime
#scheduleStartTime
#timeSinkRegisterWithControlUnit

# heat_sensor_one_pkt.txt

//**.fixhost[0].app.sinkFor = "\x2"+"\x2"+"\x0"
**.fixhost[0].app.simAppTerminationReason = 2 # when all have arrived
**.fixhost[0].app.first_proactiveRreqTimeout = 0 # zero default



#**.region[4].regionHost[0].first_proactiveRreqTimeout = ${increment} * 3
















**.region[4].regionHost[0].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[0].actionThreads = "demand_one_pkt.txt"
**.region[4].regionHost[0].scheduleStartTime = ${node1=10,  10,  10,  10,  10}
**.region[4].regionHost[0].nodeStartTime = ${node1}
**.region[4].regionHost[0].isAppliance = true

**.region[4].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[1].sinkFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[1].actionThreads = "demand_one_pkt.txt"
#**.region[4].regionHost[1].scheduleStartTime = ${node2=100, 12,  12,  12,  12 ! node1}
**.region[4].regionHost[1].scheduleStartTime = ${node2=100, 11,  11,  11,  11 ! node1}
**.region[4].regionHost[1].nodeStartTime = ${node2}
**.region[4].regionHost[1].isAppliance = true

**.region[4].regionHost[2].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[2].sinkFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[2].actionThreads = "demand_one_pkt.txt"
#**.region[4].regionHost[2].scheduleStartTime = ${node3=100, 100, 14,  14,  14 ! node1}
**.region[4].regionHost[2].scheduleStartTime = ${node3=100, 100, 12,  12,  12 ! node1}
**.region[4].regionHost[2].nodeStartTime = ${node3}
**.region[4].regionHost[2].isAppliance = true

**.region[4].regionHost[3].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[3].sinkFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[3].actionThreads = "demand_one_pkt.txt"
#**.region[4].regionHost[3].scheduleStartTime = ${node4=100, 100, 100, 16,  16 ! node1}
**.region[4].regionHost[3].scheduleStartTime = ${node4=100, 100, 100, 13,  13 ! node1}
**.region[4].regionHost[3].nodeStartTime = ${node4}
**.region[4].regionHost[3].isAppliance = true

**.region[4].regionHost[4].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[4].sinkFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[4].actionThreads = "demand_one_pkt.txt"
#**.region[4].regionHost[4].scheduleStartTime = ${node5=100, 100, 100, 100, 18 ! node1}
**.region[4].regionHost[4].scheduleStartTime = ${node5=100, 100, 100, 100, 14 ! node1}
**.region[4].regionHost[4].nodeStartTime = ${node5}
**.region[4].regionHost[4].isAppliance = true












#############################################




# Simulation completion
sim-time-limit = 30s


# CU is a sink and 5 arrivals at 
#**.expectedDataArrivals = ${expected=1, 3, 6, 10, 15 ! node1}
**.expectedDataArrivals = ${expected=0, 1, 3, 6, 10 ! node1}






# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";













[Config AODV_QueryBasedRegions]

# NB ALWAYS READ THIS BEFORE RUNNING
#####################################
# Always consider the experiment length and estimation method
# Don't forget
# seed-set = ${repetition}
# num-rngs = 2
#
# Think about explicit and default start times for everything
# first proactive route
# radio
# general start, schedule send data start
#
# Also check whether rreps on proactive route, etc etc  




# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
*.numFixHosts = 250

repeat = 25
seed-set = ${repetition}
num-rngs = 2


**.estimationMethod = "experiment"


# Control Unit related parameters
**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours, ie never

# Try using RREPs so that concentrators have a route to source for binding request
**.manetrouting.suppress_rreps_on_proactive_rreqs = true
#**.fixhost[0].udpApp.confirmRegistration = false
# multiple concentrators to request binding on sources
# really do not want this here
#**.fixhost[*].udpApp.bindWithSource = true
# first_proactiveRreqTimeout
#**.fixhost[0].udpApp.isControlUnit = true
#**.fixhost[0].mobility.initialX = 0.1m
#**.fixhost[0].mobility.initialY = 0.1m
#**.fixhost[0].mobility.initialZ = 0.75m
#**.fixhost[0].app.setParametersDirectly = true
#**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[0]"
#**.fixhost[0].manetrouting.isRoot = true





# NBNBNB
# Currently Aodv network layer (UdpBurst) uses long context
# so this works well for finding just one of the concentrators 
# Need to think more about configuration for this though   

# if sources have no binding yet they will queue data



#**.fixhost[0].udpApp.isControlUnit = true
#**.fixhost[0].mobility.initialX = 1.0m
#**.fixhost[0].mobility.initialY = 1.0m
#**.fixhost[0].mobility.initialZ = 0.5m
#**.fixhost[0].app.setParametersDirectly = true
#**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[0]"

#**.fixhost[1].udpApp.isControlUnit = true
#**.fixhost[1].mobility.initialX = 6.0m
#**.fixhost[1].mobility.initialY = 1.0m
#**.fixhost[1].mobility.initialZ = 0.5m
#**.fixhost[1].app.setParametersDirectly = true
#**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[1]"

#**.fixhost[2].udpApp.isControlUnit = true
#**.fixhost[2].mobility.initialX = 1.0m
#**.fixhost[2].mobility.initialY = 7.0m
#**.fixhost[2].mobility.initialZ = 0.5m
#**.fixhost[2].app.setParametersDirectly = true
##**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[2]"

#**.fixhost[3].udpApp.isControlUnit = true
#**.fixhost[3].mobility.initialX = 6.0m
#**.fixhost[3].mobility.initialY = 7.0m
#**.fixhost[3].mobility.initialZ = 0.5m
#**.fixhost[3].app.setParametersDirectly = true
#**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[3]"

#**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[0]"










**.region[1].regionHost[0].isControlUnit = true
**.region[1].regionHost[0].isRoot = true
**.region[1].regionHost[0].nodeStartTime = ${increment=0..1 step 0.1} * 0
**.region[1].regionHost[0].first_proactiveRreqTimeout = ${increment} * 0
**.region[1].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # see note above
**.region[1].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[1].regionHost[*].controlUnit = "csma802154net.region[1].regionHost[0]"
**.region[1].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[1].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[1].regionHost[1].scheduleStartTime = (${increment} * 0)+0.5
**.region[1].regionHost[1].isAppliance = true

**.region[2].regionHost[0].isControlUnit = true
**.region[2].regionHost[0].isRoot = true
# setting nodestart possibly unnecessary, in this secenario
# the CU just turns on radio and sets data mapping to self
# may not matter when this is done
**.region[2].regionHost[0].nodeStartTime = ${increment} * 1
**.region[2].regionHost[0].first_proactiveRreqTimeout = ${increment} * 1
**.region[2].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # see note above
**.region[2].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[2].regionHost[*].controlUnit = "csma802154net.region[2].regionHost[0]"
**.region[2].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[2].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[2].regionHost[1].scheduleStartTime = (${increment} * 1)+0.5
**.region[2].regionHost[1].isAppliance = true

**.region[3].regionHost[0].isControlUnit = true
**.region[3].regionHost[0].isRoot = true
**.region[3].regionHost[0].nodeStartTime = ${increment} * 2
**.region[3].regionHost[0].first_proactiveRreqTimeout = ${increment} * 2
**.region[3].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # see note above
**.region[3].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[3].regionHost[*].controlUnit = "csma802154net.region[3].regionHost[0]"
**.region[3].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[3].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[3].regionHost[1].scheduleStartTime = (${increment} * 2)+0.5
**.region[3].regionHost[1].isAppliance = true

**.region[4].regionHost[0].isControlUnit = true
**.region[4].regionHost[0].isRoot = true
**.region[4].regionHost[0].nodeStartTime = ${increment} * 3
**.region[4].regionHost[0].first_proactiveRreqTimeout = ${increment} * 3
**.region[4].regionHost[0].sinkFor = "\x2"+"\x2"+"\x0" # see note above
**.region[4].regionHost[0].simAppTerminationReason = 2 # when all have arrived
**.region[4].regionHost[*].controlUnit = "csma802154net.region[4].regionHost[0]"
**.region[4].regionHost[1].sourceFor = "\x2"+"\x2"+"\x0" # will use longest context
**.region[4].regionHost[1].actionThreads = "demand_one_pkt.txt"
**.region[4].regionHost[1].scheduleStartTime = (${increment} * 3)+0.5
**.region[4].regionHost[1].isAppliance = true



# Simulation completion
sim-time-limit = 7s
**.expectedDataArrivals = 4


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";











[Config AODV_QueryBased]

# This experiment...

description = ""

# Varying parameters
#*.numFixHosts = ${numNodes=50..125 step 1}
*.numFixHosts = 250

repeat = 25


# Control Unit related parameters
**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours, ie never
**.manetrouting.suppress_rreps_on_proactive_rreqs = true
**.fixhost[0].udpApp.confirmRegistration = false
#**.fixhost[0].app.nodeStartTime = 0.01


#nodeStartTime
#scheduleStartTime
#timeSinkRegisterWithControlUnit

# heat_sensor_one_pkt.txt

**.fixhost[0].app.sinkFor = "\x2"+"\x2"+"\x0"
**.fixhost[0].app.simAppTerminationReason = 2 # when all have arrived

**.fixhost[1].app.sourceFor = "\x2"+"\x2"+"\x0"
**.fixhost[1].app.actionThreads = "demand_one_pkt.txt"
**.fixhost[1].app.scheduleStartTime = ${increment=0..1 step 0.1}
**.fixhost[1].app.isAppliance = true

**.fixhost[2].app.sourceFor = "\x2"+"\x2"+"\x0"
**.fixhost[2].app.actionThreads = "demand_one_pkt.txt"
**.fixhost[2].app.scheduleStartTime = ${increment}
**.fixhost[2].app.isAppliance = true

**.fixhost[3].app.sourceFor = "\x2"+"\x2"+"\x0"
**.fixhost[3].app.actionThreads = "demand_one_pkt.txt"
**.fixhost[3].app.scheduleStartTime = ${increment}
**.fixhost[3].app.isAppliance = true

**.fixhost[4].app.sourceFor = "\x2"+"\x2"+"\x0"
**.fixhost[4].app.actionThreads = "demand_one_pkt.txt"
**.fixhost[4].app.scheduleStartTime = ${increment}
**.fixhost[4].app.isAppliance = true



# Simulation completion
sim-time-limit = 7s
**.expectedDataArrivals = 4


# Timed behaviour



#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";




[Config AODV_Experiment_1]

# This experiment...

description = ""

# Varying parameters
*.numFixHosts = ${numNodes=50..125 step 1}

# Control Unit related parameters
**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours
**.manetrouting.suppress_rreps_on_proactive_rreqs = true
**.fixhost[48].udpApp.confirmRegistration = false
**.fixhost[48].app.nodeStartTime = 0.01


# Sources 
**.region[1..4].regionHost[0].sourceFor = "\x83"+"\x2"+"\x0"
**.region[1..4].regionHost[0].actionThreads = "heat_sensor.txt"

# Sinks
**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"

**.region[1].regionHost[1..3].isAppliance = true
**.region[2].regionHost[1..3].isAppliance = true
**.region[3].regionHost[1..3].isAppliance = true
**.region[4].regionHost[1..3].isAppliance = true

# Simulation completion
sim-time-limit = 8000s
**.expectedDataArrivals = 156


# Timed behaviour
**.region[1].regionHost[1].nodeStartTime = 43.0 # enable send/receive send grads and hello
**.region[1].regionHost[1].timeSinkRegisterWithControlUnit = 43.5
**.region[1].regionHost[2].nodeStartTime = 44.0 # enable send/receive send grads and hello
**.region[1].regionHost[2].timeSinkRegisterWithControlUnit = 44.5
**.region[1].regionHost[3].nodeStartTime = 45.0 # enable send/receive send grads and hello
**.region[1].regionHost[3].timeSinkRegisterWithControlUnit = 45.5

**.region[2].regionHost[1].nodeStartTime = 46.0 # enable send/receive send grads and hello
**.region[2].regionHost[1].timeSinkRegisterWithControlUnit = 46.5
**.region[2].regionHost[2].nodeStartTime = 47.0 # enable send/receive send grads and hello
**.region[2].regionHost[2].timeSinkRegisterWithControlUnit = 47.5
**.region[2].regionHost[3].nodeStartTime = 48.0 # enable send/receive send grads and hello
**.region[2].regionHost[3].timeSinkRegisterWithControlUnit = 48.5

**.region[3].regionHost[1].nodeStartTime = 49.0 # enable send/receive send grads and hello
**.region[3].regionHost[1].timeSinkRegisterWithControlUnit = 49.5
**.region[3].regionHost[2].nodeStartTime = 50.0 # enable send/receive send grads and hello
**.region[3].regionHost[2].timeSinkRegisterWithControlUnit = 50.5
**.region[3].regionHost[3].nodeStartTime = 51.0 # enable send/receive send grads and hello
**.region[3].regionHost[3].timeSinkRegisterWithControlUnit = 51.5

**.region[4].regionHost[1].nodeStartTime = 52.0 # enable send/receive send grads and hello
**.region[4].regionHost[1].timeSinkRegisterWithControlUnit = 52.5
**.region[4].regionHost[2].nodeStartTime = 53.0 # enable send/receive send grads and hello
**.region[4].regionHost[2].timeSinkRegisterWithControlUnit = 53.5
**.region[4].regionHost[3].nodeStartTime = 54.0 # enable send/receive send grads and hello
**.region[4].regionHost[3].timeSinkRegisterWithControlUnit = 54.5


**.region[1].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[2].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[3].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[4].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[1..4].regionHost[*].nodeStartTime = 0 # enable send/receive send grads and hello


# Foursource nondes begin sending data at 70, 71, 72 and 73 seconds
**.region[1].regionHost[0].scheduleStartTime = 70.00
**.region[2].regionHost[0].scheduleStartTime = 71.00
**.region[3].regionHost[0].scheduleStartTime = 72.00
**.region[4].regionHost[0].scheduleStartTime = 73.00
**.region[1..4].regionHost[*].scheduleStartTime = 3.00





