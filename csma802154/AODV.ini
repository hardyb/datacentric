

[General]

# Miscellanious
**.debug = true
**.coreDebug = false
#**.channelNumber = 0
output-scalar-file-append = false
num-rngs = 2
cmdenv-express-mode = true
tkenv-plugin-path = ../../../Etc/plugins
# display parameters (same as channelControl parameters and mac parameters)
**.disp.carrierFrequency = 2.4GHz
**.disp.pMax = 2.0mW
**.disp.sat = -85dBm #[dBm]
**.disp.alpha = 2
**.disp.numChannels = 27
**.disp.transmitterPower = 1.0mW #[mW]
**.disp.sensitivity = -85dBm #[dBm]

# Energy model
**.phy.usageCpuActive = 7.6
**.phy.usageCpuSleep = 0.237 ## 3.3 mA for IDLE mode, 0.237 mA for Standby
**.phy.usage_radio_idle = 1.38mA #[mA]
**.phy.usage_radio_recv = 9.6mA #[mA]
**.phy.usage_radio_sleep = 0.06mA #[mA]
**.battery.nominal = 25
**.battery.capacity = 25
**.battery.voltage = 10
**.battery.resolution = 1s
**.battery.publishDelta = 0.5
**.battery.publishTime = 20s


# Common Layer 2 settings
**.wlan.ifqType = "DropTailQueue"
**.ifq.frameCapacity = 50
**.macAckWaitDuration = 0.02s # 0.00056s # Datacentric is 0.005s
**.macMaxCSMABackoffs = 7
**.macMaxFrameRetries = 5
**.phy.channelNumber				 = 11		# default 2.4G, (range [0, 26])
**.phy.transmitterPower				 = 0.1mW  	#[mW]
**.phy.sensitivity					 = -85dBm	#[dBm]
**.phy.thermalNoise				 = -110dBm	#[dBm]
**.phy.pathLossAlpha				 = 5 # Average indoor path loss 
**.phy.snirThreshold				 = 4dB
**.rxSetupTime = 0.00108s
#**.mac.BO = 8 # range [1,14]
#**.mac.SO = 4 #range [0, BO)
# channel physical parameters
*.channelControl.carrierFrequency = 2.4GHz
*.channelControl.pMax = 2.0mW
*.channelControl.sat = -85dBm
*.channelControl.alpha = 2
*.channelControl.numChannels = 27



# Common area - Average domestic property single floor
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 10m
**.constraintAreaMaxY = 12m
**.constraintAreaMaxZ = 3.5m

# half the recommended number from building automation RFC
# used for routing
*.numFixHosts = ${numNodes=50..125 step 1}


# Property region and four room regions
**.numRegions = 6
**.region[0].x = 0
**.region[0].y = 0
**.region[0].z = 0
**.region[0].w = 10
**.region[0].h = 12
**.region[0].d = 3.5
**.region[0].context = "\x06\x00"
**.region[1].x = 0
**.region[1].y = 0
**.region[1].z = 0
**.region[1].w = 5
**.region[1].h = 6
**.region[1].d = 3.5
**.region[1].context = "\x06\x01\x00"
**.region[2].x = 5
**.region[2].y = 0
**.region[2].z = 0
**.region[2].w = 5
**.region[2].h = 6
**.region[2].d = 3.5
**.region[2].context = "\x06\x02\x00"
**.region[3].x = 0
**.region[3].y = 6
**.region[3].z = 0
**.region[3].w = 5
**.region[3].h = 6
**.region[3].d = 3.5
**.region[3].context = "\x06\x03\x00"
**.region[4].x = 5
**.region[4].y = 6
**.region[4].z = 0
**.region[4].w = 5
**.region[4].h = 6
**.region[4].d = 3.5
**.region[4].context = "\x06\x04\x00"
**.region[5].x = 0
**.region[5].y = 0
**.region[5].z = 0
**.region[5].w = 1
**.region[5].h = 1
**.region[5].d = 1
**.region[5].context = ""





[Config AODVScenario_1]

#125 heterogeneous nodes particiapte in routing inside the property
#proctive routing by the control unit is NOT employed, but the control unit
#is on a known address.
#An appliance automatically attempts registration with the control unit about every second
#with 3 appliances in each room.  After 20s the sensor in each region starts sending data 

# Miscellanious
sim-time-limit = 8000s
network = csma802154net
description = "AODVScenario_1"
**.fixhost[*].udpAppType = "UDPBurstAndBroadcast"
**.udpApp.localPort = 1234
**.udpApp.destPort = 1234
**.routingFile = ""
**.ip.procDelay = 10us
**.arp.retryTimeout = 1s
**.arp.retryCount = 3
**.arp.cacheTimeout = 100s
**.routingProtocol="AODVUU"
# Not really used
**.udpApp.messageLength = 64B # Bytes
**.udpApp.sendInterval = 3s #0.25s + uniform(-0.001s,0.001s,1)
**.udpApp.burstDuration = 10s #uniform(1s,4s,1) #uniform(1s,4s,1)
**.udpApp.sleepDuration = 0s
**.udpApp.chooseDestAddrMode = "perBurst"
**.udpApp.stopTime = 0s # uniform(10s,20s,1))
**.udpApp.startTime = 30s #uniform(20s,35s)
**.udpApp.delayLimit =200s
**.udpApp.destAddrRNG = 1







# AODV Parameters
**.log_to_file = false
**.hello_jittering = true
**.optimized_hellos = true
**.expanding_ring_search = false
**.local_repair = false
**.rreq_gratuitous = true
**.rt_log_interval = 0
**.unidir_hack = 0
**.internet_gw_mode = 0
**.receive_n_hellos = 1
**.ratelimit = 1000
**.llfeedback = true # //1000
**.wait_on_reboot = 0
#**.active_timeout = 1800000 # // time in ms (30 mins)
**.active_timeout = 36000000 # 10 Hours
**.internet_gw_address = "0.0.0.0"
**.useHover = false
**.broadcastDelay=uniform(0s,0.01s) # 10 mseconds
**.unicastDelay=uniform(0s,0.005s)






# Application operating in regular AODV / Host-centric Client/Server environment not data-centric
# set which node as control unit, make control unit a commonly known address
**.fixhost[*].app.appMode = "AODV"

# Ideally we may need a way to keep the control unit in the corner
**.fixhost[48].udpApp.isControlUnit = true
**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[48]"

# Enable the possibility of broadcast communication
**.fixhost[*].udpApp.setBroadcast = true
**.fixhost[*].udpApp.outputInterfaceMulticastBroadcast = "wlan"





# One Source in each reagion
# three sinks in each region 
**.region[1..4].regionHost[0].sourceFor = "\x83"+"\x2"+"\x0"
**.region[1..4].regionHost[0].actionThreads = "heat_sensor.txt"
**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"

**.region[1].regionHost[1..3].isAppliance = true
**.region[2].regionHost[1..3].isAppliance = true
**.region[3].regionHost[1..3].isAppliance = true
**.region[4].regionHost[1..3].isAppliance = true

# One sink/source node initiate binding every second

# TEMP
**.fixhost[48].app.nodeStartTime = 1.0


**.region[1].regionHost[0].nodeStartTime = 1.0 # enable send/receive send grads and hello
**.region[1].regionHost[1].nodeStartTime = 2.0 # enable send/receive send grads and hello
**.region[1].regionHost[2].nodeStartTime = 3.0 # enable send/receive send grads and hello
**.region[1].regionHost[3].nodeStartTime = 4.0 # enable send/receive send grads and hello
**.region[2].regionHost[0].nodeStartTime = 5.0 # enable send/receive send grads and hello
**.region[2].regionHost[1].nodeStartTime = 6.0 # enable send/receive send grads and hello
**.region[2].regionHost[2].nodeStartTime = 7.0 # enable send/receive send grads and hello
**.region[2].regionHost[3].nodeStartTime = 8.0 # enable send/receive send grads and hello
**.region[3].regionHost[0].nodeStartTime = 9.0 # enable send/receive send grads and hello
**.region[3].regionHost[1].nodeStartTime = 10.0 # enable send/receive send grads and hello
**.region[3].regionHost[2].nodeStartTime = 11.0 # enable send/receive send grads and hello
**.region[3].regionHost[3].nodeStartTime = 12.0 # enable send/receive send grads and hello
**.region[4].regionHost[0].nodeStartTime = 13.0 # enable send/receive send grads and hello
**.region[4].regionHost[1].nodeStartTime = 14.0 # enable send/receive send grads and hello
**.region[4].regionHost[2].nodeStartTime = 15.0 # enable send/receive send grads and hello
**.region[4].regionHost[3].nodeStartTime = 16.0 # enable send/receive send grads and hello
**.region[1..4].regionHost[*].nodeStartTime = 17.0 # enable send/receive send grads and hello

# Foursource nondes begin sending data at 20, 21 and 23 seconds
**.region[1].regionHost[0].scheduleStartTime = 20.00
**.region[2].regionHost[0].scheduleStartTime = 21.00
**.region[3].regionHost[0].scheduleStartTime = 22.00
**.region[4].regionHost[0].scheduleStartTime = 23.00
**.region[1..4].regionHost[*].scheduleStartTime = 3.00

# Essential output stats
**.End-to-end delay.vector-recording = true
**.Mean end-to-end delay.vector-recording = true
**.RREQPacketFrequency.vector-recording = true
**.RReplyPacketFrequency.vector-recording = true
**.AODVDataPacketFrequency.vector-recording = true
**.DiscoveryPacketFrequency.vector-recording = true
**.RegisterPacketFrequency.vector-recording = true
**.dataPacketE2EDelay.vector-recording = true
**.pendingRREQVector.vector-recording = true
**.pendingRegistrationVector.vector-recording = true
**.modulesDownVector.vector-recording = true
**.AODVDataLineBreakVector.vector-recording = true
**.RERRPacketFrequency.vector-recording = true
**.PendingDataPacketsVector.vector-recording = true
**.vector-recording = false

# Other miscellanious output stats
**.Total sent.scalar-recording = true
**.Total received.scalar-recording = true
**.Total deleted.scalar-recording = true
**.Mean delay.scalar-recording = true
**.Min delay.scalar-recording = true
**.Max delay.scalar-recording = true
**.Deviation delay.scalar-recording = true

# Additional scalar recording for scatter charts in multi simulation runs
**.FailedRREQs.scalar-recording = true
**.FailedRegistrations.scalar-recording = true
**.LinkFailures.scalar-recording = true
**.DataArrivals.scalar-recording = true
**.ProactiveRREQs.scalar-recording = true
**.DataFailures.scalar-recording = true
**.ProactiveRREQFailures.scalar-recording = true

**.scalar-recording = false



[Config AODVScenario_1b]
extends = AODVScenario_1

**.expanding_ring_search = true


[Config AODVScenario_1c]
extends = AODVScenario_1

**.local_repair = false


[Config AODVScenario_1d]
extends = AODVScenario_1

**.expanding_ring_search = true
**.local_repair = false


[Config AODVScenario_1e]
extends = AODVScenario_1




#**.targetOnlyRreq = false
#**.isRoot = false  #Proactive RREQ
#**.proactiveRreqTimeout = 5000  # 5 seconds
#**.propagateProactive = true  # Proactive feedback



# This node initiates a proactive route to itself
# every 5s, starting ???
# Also each node will send a RREP providing a route back to each
**.fixhost[48].manetrouting.isRoot = true
#**.fixhost[48].manetrouting.targetOnlyRreq = true
#**.fixhost[48].manetrouting.proactiveRreqTimeout = 40000
#**.fixhost[48].manetrouting.suppress_rreps_on_proactive_rreqs = true
**.manetrouting.proactiveRreqTimeout = 36000000 # 10 Hours
**.manetrouting.suppress_rreps_on_proactive_rreqs = true

# start root at zero - sends proactive
# start key nodes at zero they will look extensively for their own root

# startup root at zero - sends proactive
# key nodes startup late, they will look for route more locally
# possibly using expanding ring
# What if all key nodes startup together

# Start the radio at 1.0
# First proactive RREQ sent at 40s
#**.fixhost[48].app.setParametersDirectly = true
**.fixhost[48].app.nodeStartTime = 0.0

#**.region[0].regionHost[48].setHostParametersDirectly = true
#**.region[1].regionHost[24].setHostParametersDirectly = true

# These start the radio at 43.0
# 0.01s later the 12 (3 x 4) sinks search for route to control Unit
**.region[1].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello

**.region[1].regionHost[1].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[1].regionHost[1].timeSinkRegisterWithControlUnit = 3.0
**.region[1].regionHost[2].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[1].regionHost[2].timeSinkRegisterWithControlUnit = 4.0
**.region[1].regionHost[3].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[1].regionHost[3].timeSinkRegisterWithControlUnit = 5.0

**.region[2].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello

**.region[2].regionHost[1].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[2].regionHost[1].timeSinkRegisterWithControlUnit = 6.0
**.region[2].regionHost[2].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[2].regionHost[2].timeSinkRegisterWithControlUnit = 7.0
**.region[2].regionHost[3].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[2].regionHost[3].timeSinkRegisterWithControlUnit = 8.0

**.region[3].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello

**.region[3].regionHost[1].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[3].regionHost[1].timeSinkRegisterWithControlUnit = 9.0
**.region[3].regionHost[2].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[3].regionHost[2].timeSinkRegisterWithControlUnit = 10.0
**.region[3].regionHost[3].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[3].regionHost[3].timeSinkRegisterWithControlUnit = 11.0

**.region[4].regionHost[0].nodeStartTime = 0 # enable send/receive send grads and hello

**.region[4].regionHost[1].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[4].regionHost[1].timeSinkRegisterWithControlUnit = 12.0
**.region[4].regionHost[2].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[4].regionHost[2].timeSinkRegisterWithControlUnit = 13.0
**.region[4].regionHost[3].nodeStartTime = 0 # enable send/receive send grads and hello
**.region[4].regionHost[3].timeSinkRegisterWithControlUnit = 14.0

**.region[1..4].regionHost[*].nodeStartTime = 0 # enable send/receive send grads and hello








# What if key nodes startup at the same time as root or even earlier
# but do not register or bind until much later, in this case they will
# have their own (proactive) route to the control unit
# HOWEVER this means the registration/binding is manual not just at startup

    















# Foursource nondes begin sending data at 70, 71, 72 and 73 seconds
**.region[1].regionHost[0].scheduleStartTime = 70.00
**.region[2].regionHost[0].scheduleStartTime = 71.00
**.region[3].regionHost[0].scheduleStartTime = 72.00
**.region[4].regionHost[0].scheduleStartTime = 73.00
**.region[1..4].regionHost[*].scheduleStartTime = 3.00




[Config AODVScenario_1f]
# In this case the sinks startup and register after the root starts
# But still with about a second between them

# Due to congestion the proactive RREQ only ever reaches about 90% of nodes
# Consequently while all of sinks' RREQs result in a large number of RREPs back
# a number of them also result in the RREQ being forwarded by nodes that were
# in that 10% who did not achieve a proactive route, one or more times.
# This all leads to significant congestion even with a second between
# registrations. 


extends = AODVScenario_1e

# specific to this config but may be unchanged - just want to be sure or recreating
**.macAckWaitDuration = 0.02s
**.macMaxCSMABackoffs = 7
**.macMaxFrameRetries = 5
**.phy.transmitterPower = 0.1mW


**.fixhost[48].udpApp.confirmRegistration = false





**.region[1].regionHost[1].nodeStartTime = 43.0 # enable send/receive send grads and hello
**.region[1].regionHost[1].timeSinkRegisterWithControlUnit = 43.5
**.region[1].regionHost[2].nodeStartTime = 44.0 # enable send/receive send grads and hello
**.region[1].regionHost[2].timeSinkRegisterWithControlUnit = 44.5
**.region[1].regionHost[3].nodeStartTime = 45.0 # enable send/receive send grads and hello
**.region[1].regionHost[3].timeSinkRegisterWithControlUnit = 45.5

**.region[2].regionHost[1].nodeStartTime = 46.0 # enable send/receive send grads and hello
**.region[2].regionHost[1].timeSinkRegisterWithControlUnit = 46.5
**.region[2].regionHost[2].nodeStartTime = 47.0 # enable send/receive send grads and hello
**.region[2].regionHost[2].timeSinkRegisterWithControlUnit = 47.5
**.region[2].regionHost[3].nodeStartTime = 48.0 # enable send/receive send grads and hello
**.region[2].regionHost[3].timeSinkRegisterWithControlUnit = 48.5

**.region[3].regionHost[1].nodeStartTime = 49.0 # enable send/receive send grads and hello
**.region[3].regionHost[1].timeSinkRegisterWithControlUnit = 49.5
**.region[3].regionHost[2].nodeStartTime = 50.0 # enable send/receive send grads and hello
**.region[3].regionHost[2].timeSinkRegisterWithControlUnit = 50.5
**.region[3].regionHost[3].nodeStartTime = 51.0 # enable send/receive send grads and hello
**.region[3].regionHost[3].timeSinkRegisterWithControlUnit = 51.5

**.region[4].regionHost[1].nodeStartTime = 52.0 # enable send/receive send grads and hello
**.region[4].regionHost[1].timeSinkRegisterWithControlUnit = 52.5
**.region[4].regionHost[2].nodeStartTime = 53.0 # enable send/receive send grads and hello
**.region[4].regionHost[2].timeSinkRegisterWithControlUnit = 53.5
**.region[4].regionHost[3].nodeStartTime = 54.0 # enable send/receive send grads and hello
**.region[4].regionHost[3].timeSinkRegisterWithControlUnit = 54.5

# This scenario expects an arrival at each of 3 appliances in each of four rooms
# On 13 occasions.  So 156 arrivals.
**.expectedDataArrivals = 156
















[Config AODVScenario_1g]
# This is the one that succeeds in setting up delivery of the sensor data
# through the control unit to the sinks
# it uses proactive route without route replies (1e) and sink confirmation to
# set up route return

extends = AODVScenario_1e

# specific to this config but may be unchanged - just want to be sure or recreating
**.macAckWaitDuration = 0.02s
**.macMaxCSMABackoffs = 7
**.macMaxFrameRetries = 5
**.phy.transmitterPower = 0.1mW


# AODVScenario_1e just creates routes to root because including
# replies to get reverse routes is too congested
# So... let control unit confirm registration and get a route that way
# Hopefully no congestion - downside, only supports one by one manual reg
**.fixhost[48].udpApp.confirmRegistration = true

**.local_repair = true


**.fixhost[48].udpApp.Instability = 0 # Completely stable
#**.fixhost[1..25].udpApp.Instability = 33 # 33% down once every 1.5 hrs
#**.fixhost[25..49].udpApp.Instability = 10 # 10% down once every 5 hrs 
**.fixhost[*].udpApp.Instability = 1  # 1% down once every 2 days (50 hrs)
#**.fixhost[*].udpApp.Instability = 0  # Completely stable


#  NB Following first run seems the RREQs and subsequent confirm data sends are
# interfering with the subsequent registration
# Seems 1s apart may nto be enough - try another one with registrations maybe 2s apart
# Tried it, still failing to get routes TO sink for 3 of them and 1 even no reg arriving
# try expanding ring, tried it, complete failure far too congested
# try mac or phy changes






[Config AODVScenario_1h]
extends = AODVScenario_1g

**.fixhost[48].udpApp.confirmRegistration = false
**.manetrouting.suppress_rreps_on_proactive_rreqs = false




[Config AODVScenario_2]

#125 heterogeneous nodes particiapte in routing inside the property

#An appliance automatically attempts registration with the control unit about every second
#with 3 appliances in each room.  After 20s the sensor in each region starts sending data 

# Miscellanious
sim-time-limit = 1000s
network = csma802154net
description = "AODVScenario_1"
**.fixhost[*].udpAppType = "UDPBurstAndBroadcast"
**.udpApp.localPort = 1234
**.udpApp.destPort = 1234
**.routingFile = ""
**.ip.procDelay = 10us
**.arp.retryTimeout = 1s
**.arp.retryCount = 3
**.arp.cacheTimeout = 100s
**.routingProtocol="AODVUU"
# Not really used
**.udpApp.messageLength = 64B # Bytes
**.udpApp.sendInterval = 3s #0.25s + uniform(-0.001s,0.001s,1)
**.udpApp.burstDuration = 10s #uniform(1s,4s,1) #uniform(1s,4s,1)
**.udpApp.sleepDuration = 0s
**.udpApp.chooseDestAddrMode = "perBurst"
**.udpApp.stopTime = 0s # uniform(10s,20s,1))
**.udpApp.startTime = 30s #uniform(20s,35s)
**.udpApp.delayLimit =200s
**.udpApp.destAddrRNG = 1

# AODV Parameters
**.log_to_file = false
**.hello_jittering = true
**.optimized_hellos = true
**.expanding_ring_search = false
**.local_repair = true
**.rreq_gratuitous = true
**.rt_log_interval = 0
**.unidir_hack = 0
**.internet_gw_mode = 0
**.receive_n_hellos = 1
**.ratelimit = 1000
**.llfeedback = false # //1000
**.wait_on_reboot = 0
**.active_timeout = 1800000 # // time in ms (30 mins)
**.internet_gw_address = "0.0.0.0"
**.useHover = false
**.broadcastDelay=uniform(0s,0.01s) # 10 mseconds
**.unicastDelay=uniform(0s,0.005s)


# Application operating in regular AODV / Host-centric Client/Server environment not data-centric
# set which node as control unit, make control unit a commonly known address
**.fixhost[*].app.appMode = "AODV"
**.fixhost[48].udpApp.isControlUnit = true
**.fixhost[*].udpApp.controlUnit = "csma802154net.fixhost[48]"

# Enable the possibility of broadcast communication
**.fixhost[*].udpApp.setBroadcast = true
**.fixhost[*].udpApp.outputInterfaceMulticastBroadcast = "wlan"


# One Source in each reagion
# three sinks in each region 
**.region[1..4].regionHost[0].sourceFor = "\x83"+"\x2"+"\x0"
**.region[1..4].regionHost[0].actionThreads = "heat_sensor.txt"
**.region[1].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[2].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[3].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"
**.region[4].regionHost[1..3].sinkFor = "\x83"+"\x2"+"\x0"

# One sink/source node initiate binding every second
**.region[1].regionHost[0].nodeStartTime = 1.0 # enable send/receive send grads and hello
**.region[1].regionHost[1].nodeStartTime = 2.0 # enable send/receive send grads and hello
**.region[1].regionHost[2].nodeStartTime = 3.0 # enable send/receive send grads and hello
**.region[1].regionHost[3].nodeStartTime = 4.0 # enable send/receive send grads and hello
**.region[2].regionHost[0].nodeStartTime = 5.0 # enable send/receive send grads and hello
**.region[2].regionHost[1].nodeStartTime = 6.0 # enable send/receive send grads and hello
**.region[2].regionHost[2].nodeStartTime = 7.0 # enable send/receive send grads and hello
**.region[2].regionHost[3].nodeStartTime = 8.0 # enable send/receive send grads and hello
**.region[3].regionHost[0].nodeStartTime = 9.0 # enable send/receive send grads and hello
**.region[3].regionHost[1].nodeStartTime = 10.0 # enable send/receive send grads and hello
**.region[3].regionHost[2].nodeStartTime = 11.0 # enable send/receive send grads and hello
**.region[3].regionHost[3].nodeStartTime = 12.0 # enable send/receive send grads and hello
**.region[4].regionHost[0].nodeStartTime = 13.0 # enable send/receive send grads and hello
**.region[4].regionHost[1].nodeStartTime = 14.0 # enable send/receive send grads and hello
**.region[4].regionHost[2].nodeStartTime = 15.0 # enable send/receive send grads and hello
**.region[4].regionHost[3].nodeStartTime = 16.0 # enable send/receive send grads and hello
**.region[*].regionHost[*].nodeStartTime = 17.0 # enable send/receive send grads and hello

# Foursource nondes begin sending data at 20, 21 and 23 seconds
**.region[1].regionHost[0].scheduleStartTime = 20.00
**.region[2].regionHost[0].scheduleStartTime = 21.00
**.region[3].regionHost[0].scheduleStartTime = 22.00
**.region[4].regionHost[0].scheduleStartTime = 23.00
**.region[*].regionHost[*].scheduleStartTime = 3.00

# Essential output stats
**.End-to-end delay.vector-recording = true
**.Mean end-to-end delay.vector-recording = true
**.RREQPacketFrequency.vector-recording = true
**.RReplyPacketFrequency.vector-recording = true
**.AODVDataPacketFrequency.vector-recording = true
**.DiscoveryPacketFrequency.vector-recording = true
**.RegisterPacketFrequency.vector-recording = true
**.dataPacketE2EDelay.vector-recording = true
**.vector-recording = false

# Other miscellanious output stats
**.Total sent.scalar-recording = true
**.Total received.scalar-recording = true
**.Total deleted.scalar-recording = true
**.Mean delay.scalar-recording = true
**.Min delay.scalar-recording = true
**.Max delay.scalar-recording = true
**.Deviation delay.scalar-recording = true
**.scalar-recording = false







#######################################################################
#######################################################################
#######################################################################
#######################################################################
#######################################################################
#######################################################################
#######################################################################

#**.dataCentricNetworkMan.sources = "\x06\x01"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x02"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x03"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x04"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt"
								   # ENVIRONMENTAL_EVENTBASED+TEMP+STRINGEND

#**.dataCentricNetworkMan.sinks = "\x06\x01"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x02"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x03"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x04"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR"
								   # ENVIRONMENTAL_EVENTBASED+TEMP+STRINGEND


#tkenv-default-run=1

#        PREPREPARED STRINGS FOR USE
#        string STRINGEND = "\x0";
#        string DEMAND_QUERYBASED = "\x2";
#        string DEMAND_COLLABERATIONBASED = "\x42";
#        string ENVIRONMENTAL_EVENTBASED = "\x83";
#        string CURRENT = "\x2";
#        string BID = "\x1";
#        string OCCUPANCY = "\x1";
#        string TEMP = "\x2";

#**.host*.mobility.updateInterval = 0.1
#**.host*.mobility.traceFile = "escen_v5_t500-1.txt"

#**.fixhost[*].app.nodeContext = "\x06"

#**.fixhost[*].udpApp.outputInterface = "wlan"

#**.fixhost[36].app.nodeStartTime = 1.0 # enable send/receive send grads and hello
#**.fixhost[13].app.nodeStartTime = 3.0 # enable send/receive send grads and hello
#**.fixhost[*].app.nodeStartTime = 1.0 # enable send/receive send grads and hello

#**.fixhost[13].app.scheduleStartTime = 10.1 # begin pattern of sending data, eg temp, watts, occupancy
#**.fixhost[*].app.scheduleStartTime = 3.00 # begin pattern of sending data, eg temp, watts, occupancy

#**.fixhost[36].app.sinkFor = "\x2"+"\x2"+"\x0" # DEMAND_QUERYBASED+CURRENT+STRINGEND
#**.fixhost[13].app.sourceFor = "\x2"+"\x2"+"\x0" # DEMAND_QUERYBASED+CURRENT+STRINGEND
#**.fixhost[13].app.actionThreads = "Fridge.txt"

# Scenario X
# four regions, each with one publication source for temperature and three sinks.  
# Currently they can only be all started at the same time until the config feature is improved
################################################################################################

#**.fixhost[*].app.nodeStartTime = 1.0 # enable send/receive send grads and hello
#**.fixhost[*].app.scheduleStartTime = 3.00 # begin pattern of sending data, eg temp, watts, occupancy


#**.dataCentricNetworkMan.sources = "\x06\x01"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x02"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x03"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt,"+\
#								   "\x06\x04"+",0,0,"+"\x83"+"\x2"+"\x0"+",heat_sensor.txt"
								   # ENVIRONMENTAL_EVENTBASED+TEMP+STRINGEND

#**.dataCentricNetworkMan.sinks = "\x06\x01"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x02"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x03"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR,"+\
#								 "\x06\x04"+",1,3,"+"\x83"+"\x2"+"\x0"+",sink_NR"
								   # ENVIRONMENTAL_EVENTBASED+TEMP+STRINGEND

#**.host[*].app.actionThreads = ""

#**.host*.mobility.updateInterval = 0.1s

#**.host*.mobility.changeInterval = truncnormal(5, 0.5)
#**.host*.mobility.changeAngleBy = normal(0, 90)
#**.host*.mobility.speed = 2


# This part of udpburst not used
# long term need to ditch much of what we hijacked in from udpburst
#**.udpApp.messageLength = 64B # Bytes
#**.udpApp.sendInterval = 3s #0.25s + uniform(-0.001s,0.001s,1)
#**.udpApp.burstDuration = 10s #uniform(1s,4s,1) #uniform(1s,4s,1)
#**.udpApp.sleepDuration = 0s
#**.udpApp.chooseDestAddrMode = "perBurst"
#**.udpApp.stopTime = 0s # uniform(10s,20s,1))
#**.udpApp.startTime = 30s #uniform(20s,35s)
#**.udpApp.delayLimit =200s
#**.udpApp.destAddrRNG = 1



# tcp apps (off)
#**.numTcpApps = 0
#**.tcpAppType = "TelnetApp"

# ping app (host[0] pinged by others)
# ping app (off)
#**.pingApp.destAddr = ""
#**.pingApp.srcAddr = ""
#**.pingApp.packetSize = 56B
#**.pingApp.interval = 1s
#**.pingApp.hopLimit = 32
#**.pingApp.count = 0
#**.pingApp.startTime = 1s
#**.pingApp.stopTime = 0
#**.pingApp.printPing = true

#*.fixhost[0].pingApp.destAddr=""
#*.host[*].pingApp.destAddr="fixhost[0]"
#**.pingApp.srcAddr=""
#**.pingApp.packetSize=56
#**.pingApp.interval =1
#**.pingApp.hopLimit=32
#**.pingApp.count=0
#**.pingApp.startTime=uniform(1,5)
#**.pingApp.stopTime=0
#**.pingApp.printPing=true

# tcp settings
#**.tcp.mss = 1024
#**.tcp.advertisedWindow = 14336 # 14*mss
#**.tcp.sendQueueClass = "TCPMsgBasedSendQueue"
#**.tcp.receiveQueueClass = "TCPMsgBasedRcvQueue"
#**.tcp.tcpAlgorithmClass = "TCPReno"
#**.tcp.recordStats = true

#**.networklayer.proxyARP = true # Host's is hardwired "false"
# **.IPForward=false
#**.routingProtocol.use-default=yes

#**.mac.aUnitBackoffPeriod = 0
#**.mac.ccaDetectionTime = 0


#/ parameters : DYMOUM
#**.no_path_acc_ = false
#**.reissue_rreq_ = false
#**.s_bit_ = false
#**.hello_ival_ = 0
#**.MaxPktSec = 20 #// 10
#**.promiscuous = false
#**.NetDiameter = 10
#**.RouteTimeOut = 3000
#**.RouteDeleteTimeOut = 3000*5 #//5*RouteTimeOut
#**.RREQWaitTime = 1000
#**.RREQTries =3
#**.noRouteBehaviour=1


#**.use-default=yes

# proccesing delay in the routing protocol, avoid syncronization

#**.fixhost[0].**.costStatic = 10
#**.fixhost[1].**.costStatic = 10
#**.fixhost[5].**.costStatic = 10
#**.fixhost[6].**.costStatic = 10
#**.fixhost[10].**.costStatic = 10
#**.fixhost[11].**.costStatic = 10
#**.fixhost[15].**.costStatic = 10
#**.fixhost[16].**.costStatic = 10



# // parameters: DSRUU;
#**.PrintDebug = true
#**.FlushLinkCache = true
#**.PromiscOperation = false
#**.UseNetworkLayerAck = false
#**.BroadCastJitter = 20 # 20 ms
#**.RouteCacheTimeout = 300 #300 seconds
#**.SendBufferTimeout = 300# //30 s
#**.SendBufferSize = -1
#**.RequestTableSize = -1
#**.RequestTableIds = -1
#**.MaxRequestRexmt = -1 #// 16,
#**.MaxRequestPeriod = 10 #//10 SECONDS
#**.RequestPeriod = 500 #//500 MILLISECONDS
#**.NonpropRequestTimeout = 30# //30 MILLISECONDS
#**.RexmtBufferSize = -1 #//MAINT_BUF_MAX_LEN
#**.MaintHoldoffTime = 250# //250 MILLISECONDS
#**.MaxMaintRexmt = 2 # //2
#**.TryPassiveAcks = true #//1
#**.PassiveAckTimeout = 100# //100 MILLISECONDS
#**.GratReplyHoldOff = 1 #, //1 SECONDS
#**.MAX_SALVAGE_COUNT = 15 # //15
#**.LifoSize = 20
#**.PathCache = true
#**.ETX_Active=false
#**.ETXHelloInterval = 1 #, // Second
#**.ETXWindowNumHello = 10
#**.ETXRetryBeforeFail=-1
#**.RREPDestinationOnly = false
#**.RREQMaxVisit =5 # // Max Number that a RREQ can be processes by a node

#// Olsr
#**.Willingness=3
#**.Hello_ival=2
#**.Tc_ival=5
#**.Mid_ival=5
#**.use_mac =0 #1
#**.Mpr_algorithm = 1
#**.routing_algorithm = 1
#**.Link_quality = 2
#**.Fish_eye = false
#**.Tc_redundancy = 3
#**.Link_delay = true #//default false
#**.C_alpha=0.2

#// DSDV
#**.hellomsgperiod_DSDV = 1s # //Period of DSDV hello message generation [seconds]
#**.timetolive_routing_entry = 5s # // ;[seconds]
#**.netmask = "255.255.0.0" # //
#**.MaxVariance_DSDV = 1
#**.RNGseed_DSDV = 0
